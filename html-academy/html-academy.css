/*
- ссылки одни из тех элементов, которые имеют браузерную стилизацию по умолчанию — для них указан синий цвет. Чтобы переопределить синий цвет по умолчанию у нас есть два варианта: сделать свойство наследуемым (color: inherit) или указать необходимый цвет. 
*/

/*
Адрес размечен с помощью тега <address>, поэтому нужно указать ему font-style: normal;. Дело в том, что у тега <address> для этого CSS-свойства есть браузерные стили по умолчанию, которые нам нужно переопределить.

.contacts-address {
  font-style: normal;
}

*/

/*
Грид-областью называют часть сетки грид-контейнера, у которой может быть имя. Имя области придумывает сам разработчик. Оно должно начинаться с буквы и может включать цифры, дефис и знак подчёркивания. Например: header, section-2, user_avatar. Следует выбирать такие имена, которые описывают содержимое области.

Чтобы описать структуру грида с помощью областей, используют свойство grid-template-areas. В нём указывают имена грид-областей. При этом каждый ряд оборачивают в кавычки, а колонки разделяют пробелом. Если требуется растянуть область на несколько колонок, её имя повторяют нужное число раз.

Нам нужно растянуть заголовок на две колонки и переместить блок с ценой в первый ряд:

.card {
  display: grid;
  grid-template-columns: 260px 165px 75px;
  grid-template-areas: "title title price";
}

Однако просто описать шаблон недостаточно, ведь браузер не знает, какие элементы мы имеем в виду. Чтобы связать имя области с соответствующим грид-элементом, используют свойство grid-area. Обратите внимание, в grid-area кавычки не нужны!

.title {
  grid-area: title;
}

.price {
  grid-area: price;
}

В grid-template-areas можно указать сколько угодно рядов. При этом в кавычки оборачивают каждый ряд, но точка с запятой ставится только после последнего ряда! Для большей наглядности ряды записывают друг под другом:

grid-template-areas: "title title price"
                     "options description description";
Чтобы растянуть область на несколько рядов, достаточно повторить её имя в разных рядах. Нам нужно растянуть список опций на два ряда:

grid-template-areas: "title title price"
                     "options description description"
                     "options disclaimer disclaimer";

Спецификация по грид-областям https://www.w3.org/TR/css3-layout/#grid-template-areas                     

*/

/* Флексы. Погружение.

Ширина, высота, внутренние отступы и рамки для флекс-контейнеров и флекс-элементов работают как обычно: общий размер элементов складывается из этих компонентов. Это поведение также можно менять с помощью свойства box-sizing.

Есть и несколько важных отличий:

флекс-элементы, в отличие от блочных элементов, не растягиваются на всю ширину контейнера по умолчанию;
на флекс-элементы не действует свойство float.

свойство margin:

внешние отступы не схлопываются, ни по горизонтали, ни по вертикали;

внешние отступы не выпадают, ни из флекс-контейнера, ни из флекс-элементов;

значение auto получило премию журнала Форбс в номинации «Самое влиятельное значение CSS-свойства внутри флекс-контейнера».

Всё дело в механизме распределения свободного места. Если внутри флекс-контейнера есть свободное место, то оно перераспределяется так:

находятся элементы, у которых есть внешние отступы со значением auto;

всё свободное место в соответствующих направлениях отдаётся таким отступам (то есть задаётся определённый размер отступа в пикселях);

если элементов с автоматическими отступами на одном направлении несколько, то место между ними перераспределяется поровну;

только после этого запускаются механизмы выравнивания.

А хотелось бы иметь «умное» свойство для задания размера флекс-элементов, которое знает про главную ось и «поворачивается» вместе с ней.

И такое свойство есть — это flex-basis. Оно задаёт базовый размер флекс-элемента или размер вдоль главной оси.

*/

/* ГРАФИКА
Простые фигуры можно нарисовать с помощью свойств CSS.

*/

/* ШРИФТЫ
https://up.htmlacademy.ru/profession/frontender-lite/2/lite-htmlcss/2/module/3/item/12
https://www.youtube.com/watch?v=uI3Q5m9xkkw&feature=youtu.be


*/

/* Dev Tools - Styles

Браузер пишет, что данные свойства унаследованы от селектора body (Inherited from body). Полупрозрачными выделены те свойства, которые не наследуются выбранным DOM-элементом, а непрозрачные - те, которые явно наследуются.

*/

/* ДЕКОРАТИВНЫЕ ЭЛЕМЕНТЫ

Позиционирование:

position: relative;
относительно спозиционированный элемент на самом деле никуда не смещается. Он остаётся в потоке ровно там же, где и был (это место обозначено блоком-тенью). А смещается иллюзорная копия блока.

Свойства left, top, right и bottom по-разному работают для элементов с абсолютным и относительным позиционированием.

Если для «относительных» элементов эти свойства задают смещение относительно исходной позиции, то для «абсолютных» элементов они задают расположение относительно некой системы координат, как для точки на графике.

*/

/* Типы CSS-значений

Помимо процентов есть и другие относительные единицы измерения.

width: 50%;       От ширины родителя 
width: 100vw;     От ширины вьюпорта 
height: 100vh;    От высоты вьюпорта 
font-size: 2em;   От размера шрифта родителя 
font-size: 2rem;  От размера шрифта корневого элемента (html) 

Цветовые значения

color: #f00;       #f  0  0 
color: #ff0000;    #ff 00 00 
color: rgb(255, 0, 0);
color: rgba(255, 0, 0, 0.5);
color: hsl(0, 100%, 50%);
color: hsla(0, 100%, 50%, 0.5);

Значения-функции
Следующий тип значений — функции. Их не так много. Но особенно полезны функции calc и linear-gradient.

Получает содержимое атрибута 
content: attr(href);

Любые расчёты 
width: calc(100% - 100px);

Линейный градиент 
background-image:
  linear-gradient(45deg, yellow, green);

  CSS-директивы
Наш разговор про синтаксис CSS завершается. Напоследок вкратце упомянем про CSS-директивы. Это специальные конструкции, которые начинаются с символа @. Директивы чаще всего влияют на весь документ, но сами по себе ничего не стилизуют. Например, директива @font-face позволяет подключать на страницу нестандартные шрифты, которые потом можно использовать в свойстве font-family. Или директива @media, которая при определённых условиях активирует или деактивирует какие-то CSS правила. Директиву @font-face вы будете использовать уже на этом уровне. С помощью @media делают адаптивную вёрстку, которую мы детально разбираем на втором уровне.

@font-face {
  font-family: "Open Sans";
  src:
    url("OpenSans-Regular.woff2") format("woff2"),
    url("OpenSans-Regular.woff") format("woff");
}

@media (max-width: 600px) {
  .sidebar {
    display: none;
  }
}

*/

/* Слова, часто используемые в CSS-классах
https://github.com/yoksel/common-words

*/

/* VISUALLY-HIDDEN

position: absolute;
clip: rect(0 0 0 0);
width: 1px;
height: 1px;
margin: -1px;

-----
<div hidden>Вырублен</div>

*/ 

/* Особенности transform-origin — часть 1

Это свойство используется совместно со свойством transform и задаёт точку отсчёта системы координат, в рамках которой будет работать трансформация.

Синтаксис transform-origin для двухмерных трансформаций следующий:

transform-origin: точка-отсчёта-по-X [точка-отсчёта-по-Y]
Значения свойства задаётся в единицах измерения ширины в браузере (px, em...), в %, а также ключевыми словами left, right, top, bottom и center.

По умолчанию, значение transform-origin равно 50% 50%, то есть начало системы координат находится в центре объекта. Если не указывать значение точка-отсчёта-по-Y, то оно считается равным 50%.

При помощи transition трансформацию можно сделать плавной

*/

/* Оформление текста. Погружение https://up.htmlacademy.ru/profession/frontender-lite/2/lite-htmlcss/2/module/8/item/4/21
Если попробовать задать для кириллицы или латиницы обратное направление текста (справа налево) direction: rtl;, мы увидим, что текст в блоке выровнялся наоборот, и полоса прокрутки блока сменила своё положение на противоположное. Но при этом сам текст не стал менять своё направление. Это произошло потому, что браузер автоматически задал тексту корректное направление, проанализировав используемые символы Unicode. Чтобы повлиять на это решение браузера существует свойство unicode-bidi, принимающее значения:

normal — браузер самостоятельно определяет, как ему следует отображать текст на основе используемых символов Unicode;
embed — переопределяет направление текста, располагая его согласно свойству direction (применяется, когда в блоке текст на двух разнонаправленных языках);
bidi-override — переопределяет порядок символов в тексте согласно значению direction.

*/

/*

*/


/*

*/


/*

*/


/*

*/


/*

*/


/*

*/


/*

*/


/*

*/


/*

*/


/*

*/



