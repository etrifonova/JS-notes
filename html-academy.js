

/*

*/

/* ОБЪЕКТЫ

Объект — тип данных, который хранит в себе информацию в виде пар «ключ-значение».

Запись объекта со всеми свойствами в фигурных скобках, называется литералом объекта. Если необходимо создать объект с помощью литерала, вам просто нужно использовать фигурные скобки. И если у объекта есть какие-то свойства, записать их внутри этих скобок.

let catsFavoriteFood = {
  Кекс: 'рыба',
  Рудольф: 'котлета',
  Снежок: 'сметана'
};

let printFavoriteFood = function (name) {
  return 'Моя любимая еда — ' + catsFavoriteFood[name];
};

console.log(printFavoriteFood('Снежок')); // Выведет: Моя любимая еда — сметана
Код работает, как и прежде, зато насколько сократилась наша программа!

Мы записали в объект не характеристику вида name: 'Кекс', а соотношение имени кота и лакомства, которое по вкусу именно ему. Такие объекты называют словарями, мапами или ассоциативными массивами. 

Скобочная нотация намного гибче точечной. Например, вы можете прочитать из объекта свойство, название которого записано в переменную:

let name = 'Кекс';
let catsFavoriteFood = { 'Кекс': 'рыба' };

console.log(catsFavoriteFood.name); // Выведет: undefined

console.log(catsFavoriteFood[name]); // Выведет: рыба
----------
console.log(catsFavoriteFood[name]);
// Незаметно внутри программы превращается в:
console.log(catsFavoriteFood['Кекс']);
----------

let cat = {
  name: 'Рудольф',

  introduce: function () {
    console.log('Мяу! Я кот ' + this.name + '!');
  }
};

cat.introduce(); // Выведет: Мяу! Я кот Рудольф!
Объект, на который указывает this называется контекстом вызова.

Важная деталь: пока функция не вызвана, this не содержит никакого значения, контекст появляется только в момент вызова функции.



*/

/* МАССИВЫ 

Рефакторинг — это переписывание программы, после которого она должна работать так же, но быть более гибкой. Цель нашего рефакторинга — снизить трудоёмкость добавления и изменения массивного количества данных.

Массивы создаются с помощью так называемого литерала массива — квадратных скобок. Внутри скобок через запятую перечисляются все значения, которые должен содержать массив. При создании массив, как любое значение, можно записать в переменную:

let numbers = [1, 2, 3, 4, 5];

Традиционное название переменной цикла i — это сокращение от index, то есть индекса или порядкового номера. Это тоже одно из соглашений среди программистов, которое позволяет сократить код.



*/


/* for loop / цикл for

1) Первая часть — подготовительная. Команды отсюда запускаются один раз перед началом работы цикла. Обычно здесь задаётся исходное значение для переменной-счётчика. Можно сказать, что первая часть — стартовая настройка для цикла.

В примере ниже мы создали переменную-счётчик i и задали ей начальное значение 0. Именно этому значению будет равна переменная, когда цикл начнёт свою работу.

Обратите внимание, что в цикле мы создаём переменную-счётчик с помощью let, как в случае с любой другой переменной. Традиционно такая переменная называется i (от слова index), но у неё может быть любое другое название. Например, если цикл считает дни, переменная-счётчик может называться day, а если страницы документа, то page.

for (let i = 0; i < 5; i = i + 1) { }

2) Вторая часть — проверочная. Она содержит условие и запускается перед каждым новым витком цикла. Условие здесь работает по знакомому вам алгоритму. Если условие возвращает true, цикл делает ещё один виток, иначе цикл завершает свою работу.

В примере мы указали, что цикл должен работать пока переменная i будет меньше 5.

for (let i = 0; i < 5; i = i + 1) { }

3) Третья часть — дополняющая, хотя по-научному она называется «законом изменения». Код третьей части запускается после каждого витка цикла. То есть после того, как выполнится код из тела цикла. Обычно там изменяется переменная-счётчик.

В нашем случае мы указали, что после каждого витка цикла, переменная i должна увеличиваться на единицу.

for (let i = 0; i < 5; i = i + 1) { }

Комбинировать можно не только сложение, но и остальные математические операции: вычитание -=, умножение *=, деление /= и нахождение остатка %=. Например, i *= 10 будет аналогично i = i * 10.
*/